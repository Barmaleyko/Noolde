{
  "name": "PostgresClient",
  "version": "0.0.2",
  "description": "A PostgreSQL client library for Node.js",
  "homepage": "http://github.com/Frans-Willem/node-PostgresClient.git",
  "engine": [
    "node >=0.1.90"
  ],
  "author": {
    "name": "Frans-Willem Hardijzer",
    "email": "fw@hardijzer.nl"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/Frans-Willem/node-PostgresClient.git"
  },
  "directories": {
    "lib": "./lib"
  },
  "main": "./lib/PostgresClient",
  "dependencies": {
    "bufferlib": ">=0.0.6",
    "strtok": ">=0.1.0"
  },
  "readme": "# node-PostgresClient\r\nThis module is an implementation of the PostgreSQL Frontend-Backend protocol using Node.js' net and event libraries.\r\n## Dependencies\r\nnode-PostgresClient depends on the following modules:\r\n\r\n* [node-BufferLib](http://github.com/Frans-Willem/node-BufferLib) by [me](http://github.com/Frans-Willem/)\r\n* [node-strtok](http://github.com/pgriess/node-strtok) by [Peter Griess](http://github.com/pgriess)\r\n\r\n## Installing\r\n### From NPM\r\nOn the shell:\r\n\r\n\tnpm install PostgresClient\r\n\r\nIn your JS file\r\n\r\n\tvar PostgresClient=require(\"PostgresClient\").PostgresClient;\r\n\r\n### Manually\r\nOn the shell:\r\n\r\n\tmkdir libraries\r\n\tcd libraries\r\n\tmkdir repos\r\n\tcd repos\r\n\tgit clone git://github.com/Frans-Willem/node-PostgresClient.git\r\n\tgit clone git://github.com/Frans-Willem/node-BufferLib.git\r\n\tgit clone git://github.com/pgriess/node-strtok.git\r\n\tcd ..\r\n\tln -s ./repos/node-BufferLib/lib bufferlib\r\n\techo \"module.exports=require('./repos/node-PostgresClient/lib/PostgresClient');\" > PostgresClient.js\r\n\techo \"module.exports=require('./repos/node-strtok/lib/strtok');\" > strtok.js\r\n\tcd ..\r\n\t\r\n\r\nIn your JS file\r\n\r\n\trequire.paths.unshift(__dirname+\"/libraries\");\r\n\tvar PostgresClient=require(\"PostgresClient\").PostgresClient;\r\n\t\r\n## Features supported\r\n* Simple queries\r\n* Parametrized queries\r\n* Prepared statements\r\n* LISTEN/NOTIFY\r\n* COPY ... FROM STDIN, COPY ... TO STDOUT\r\n* Blocks (Transactions)\r\n\r\n## Multiple queries\r\nAlthough multiple queries of the form:\r\n\r\n\t\"SELECT 1; SELECT 2; SELECT 3;\"\r\n\r\nare supported in simpleQuery, it is _highly_ discouraged.\r\nIf one of the queries fails, all results from that command will be discarded.\r\n## Creating a new client\r\n\r\n\tvar PostgresClient=require(\"postgresclient\").PostgresClient;\r\n\tvar options={\r\n\t\thostname: \"localhost\",\r\n\t\tdatabase: \"database\",\r\n\t\tusername: \"username\",\r\n\t\tpassword: \"********\"\r\n\t};\r\n\tvar db=new PostgresClient(options);\r\n## Events\r\n### 'connect'\r\narguments: none\r\nSuccesfully connected to the PostgreSQL server.\r\n### 'error'\r\narguments: error\r\nError, no more events will be thrown after this, and no more queries will be accepted.\r\n### 'end'\r\narguments: none\r\nGraceful connection close, no more events will be thrown after this, and no more queries will be accepted.\r\n### 'notice'\r\narguments: notice\r\nA notice was received from the server, for example when going down for a reboot.\r\nThe notice object can contain any of [these](http://developer.postgresql.org/pgdocs/postgres/protocol-error-fields.html) fields (by name, not by code).\r\nSee NoticeResponse command from the protocol.\r\n### 'parameter'\r\narguments: name, value\r\nSee ParameterStatus command from the protocol.\r\n### 'notification'\r\narguments: server_pid,name,payload\r\nA NOTIFY was triggered on a name that was LISTEN'ed for.\r\nSee NotificationResponse protocol command.\r\n## Simple queries\r\nSimple queries without parameters can be sent like this:\r\n\r\n\tdb.simpleQuery(\"SELECT 1;\",function(err,rows,result) {\r\n\t\tif (err) {\r\n\t\t\tsys.puts(\"OH NOES! \"+err);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tsys.puts(\"Output from \"+result);\r\n\t\tsys.puts(sys.inspect(rows));\r\n\t});\r\n\r\nNote that the callback can also be an object as described in Query callbacks.\r\n## Extended queries\r\nFor queries with parameters, you should use extendedQuery, like this:\r\n\r\n\tdb.simpleQuery(\"SELECT $1::int AS one, $2::int AS two, $3::int AS three;\",[1,2,3],function(err,rows,result) {\r\n\t\tif (err) {\r\n\t\t\tsys.puts(\"OH NOES! \"+err);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tsys.puts(\"Output from \"+result);\r\n\t\tsys.puts(sys.inspect(rows));\r\n\t});\r\n\r\nAgain, the callback can also be an object.\r\nAlso, please note that although this example specifies type ('::int') and names (' AS one') for each parameter, this is only needed when PostgreSQL can't find out on its own.\r\nIn normal queries, '$1' and '$2' will usually suffice.\r\n## Prepared statements\r\n### Raw method\r\nThe normal method for creating and using prepared statements is as follows:\r\n\r\n\tdb.parse(\"SELECT $1::int AS one;\",function(err,name) {\r\n\t\tif (err) {\r\n\t\t\tsys.puts(\"Error parsing statement: \"+err);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tdb.bindExecute(name,[1],function(err,rows,result) {\r\n\t\t\tif (err) {\r\n\t\t\t\tsys.puts(\"Error binding statement: \"+err);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tsys.puts(\"Output from \"+result);\r\n\t\t\tsys.puts(sys.inspect(rows));\r\n\t\t\t\r\n\t\t\tdb.closeStatement(name,function(err) {\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\tsys.puts(\"Unable to close prepared statement\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsys.puts(\"Closed prepared statement\");\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\t});\r\n\r\nFor bindExecute, callback can also be an object. parse and closeStatement should have the form of the example above.\r\nThe name given to the prepared statement will be automatically generated, and you should not depend on it having a certain value, but rather just store it after the .parse callback.\r\nIf you no longer intend to use a prepared statement, you should call closeStatement to allow the database to discard it.\r\nIf you intend to use the prepared statement over the course of the database connection, you can safely ignore closeStatement, as it will be cleaned up automatically when the connection is closed.\r\n### Helper\r\nBecause the above method is rather cumbersome, a helper function was added:\r\n\r\n\tvar p=db.prepare(\"SELECT $1::int AS one;\");\r\n\tp.execute([1],function(err,rows,result) {\r\n\t\t/* this should be obvious by now */\r\n\t});\r\n\tp.close(function(err) {});\r\n\t\r\ndb.prepare will create a helper object with the execute and close functions as wrapper for bindExecute and closeStatement.\r\nYou do not have to wait for the parsing to be done, all queries or close functions will be held until the parse is complete.\r\n## LISTEN/NOTIFY\r\nLISTEN and NOTIFY can be sent as simple, extended, or prepared queries. A response from a LISTEN command will be emitted as a 'notification' event.\r\n## COPY ... FROM STDIN, COPY ... TO STDOUT\r\nCOPY ... FROM STDIN and COPY ... TO STDOUT are supported by simple, extended, or prepared queries.\r\n### COPY ... TO STDOUT\r\nFor a COPY TO operation, simply implement the copyOut, copyData, or copyDone callbacks.\r\n### COPY ... FROM STDIN\r\nFor a COPY FROM operation, you _must_ implement a copyIn callback.\r\nBecause special care must be taken with CopyIn commands to not send anything else until the command is done, you have to tell the client that a CopyIn is expected by specifying a copyIn callback.\r\n\r\nIf you're not sure if a query contains COPY ... FROM STDIN (for example when the query comes from user input), you should _always_ implement the copyIn callback, and call stream.fail(\"Not prepared\"); if you're not prepared to handle the COPY command.\r\n\r\nIf you do a COPY ... FROM STDIN command without specifying a copyIn callback, the client will automatically disconnect to prevent any desynchronization of the protocol.\r\n## Blocks (Transactions)\r\nSometimes you need to make sure a bunch of queries are executed without interruptions.\r\nNormally this can be achieved by simply doing the queries in succession, but due to the asynchronous evented nature of Node.js, this is not always possible.\r\nThis is why node-PostgresClient has blocks. A block is a promise that between the start and end of the block, _only_ queries belonging to that block will be executed.\r\nPlease note that you should always make sure a block is properly ended. If you don't, queries not part of that block will be paused forever, and the database will be unusable.\r\nFor an example of this, see blocktest.js\r\n### Starting\r\n\r\n\tbl=db.startBlock();\r\n\r\n### Ending\r\n\r\n\tdb.endBlock(bl);\r\n\r\n### Sending\r\n\r\n\tdb.simpleQuery(\"SELECT 1;\",bl,callback);\r\n\tdb.extendedQuery(\"SELECT $1::int;\",[1],bl,callback);\r\n\tdb.bindExecute(statement,[1],bl,callback);\r\n\tdb.prepare(\"SELECT $1::int;\").execute([1],bl,callback);\r\n### Sub blocks\r\nBlocks can also be part of other blocks. e.g. the following workflow:\r\n\r\n\topen block 1\r\n\tsend Q6 without a block\r\n\tsend Q1 to block 1\r\n\topen block 1.1\r\n\tsend Q2 to block 1.1\r\n\tsend Q4 to block 1\r\n\tsend Q3 to block 1.1\r\n\tend block 1.1\r\n\tsend Q5 to block 1\r\n\tend block 1\r\n\r\nWill result in the following order of queries being executed:\r\n\r\n\tQ1,Q2,Q3,Q4,Q5,Q6\r\n\t\r\nYou can open a sub block like this:\r\n\r\n\tvar subblock=db.startBlock(parentblock);\r\n\r\n### Transactions\r\nAn example of a proper transaction using blocks would look like this:\r\n\r\n\tvar block=db.startBlock();\r\n\tdb.simpleQuery(\"BEGIN TRANSACTION;\",block,function(err,rows,result) {\r\n\t\tif (err) {\r\n\t\t\tsys.puts(\"BEGIN failed\");\r\n\t\t\tdb.endBlock(block);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tdb.simpleQuery(\"UPDATE table SET x=x+1 WHERE y=0;\",block,function(err,rows,result) {\r\n\t\t\tif (err) {\r\n\t\t\t\tsys.puts(\"UPDATE(1) failed\");\r\n\t\t\t\tdb.simpleQuery(\"ROLLBACK TRANSACTION;\",block,function(){});\r\n\t\t\t\tdb.endBlock(block);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tdb.simpleQuery(\"UPDATE table SET z=z+1 WHERE z=1;\",block,function(err,rows,result) {\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\tsys.puts(\"UPDATE(2) failed\");\r\n\t\t\t\t\tdb.simpleQuery(\"ROLLBACK TRANSACTION;\",block,function(){});\r\n\t\t\t\t\tdb.endBlock(block);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdb.simpleQuery(\"COMMIT TRANSACTION;\",block,function(err,rows,result) {\r\n\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\tsus.puts(\"COMMIT failed\");\r\n\t\t\t\t\t\t\tdb.simpleQuery(\"ROLLBACK TRANSACTION;\",block,function() {});\r\n\t\t\t\t\t\t\tdb.endBlock(block);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tsys.puts(\"Committed\");\r\n\t\t\t\t\t\t\tdb.endBlock(block);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\t});\r\n\r\nThis example will do:\r\n\r\n\tBEGIN TRANSACTION;\r\n\tUPDATE table SET x=x+1 WHERE y=0;\r\n\tUPDATE table SET z=z+1 WHERE x=1;\r\n\tCOMMIT TRANSACTION;\r\n\r\nWhile making sure that no other queries will be interspersed with it by using a block, as well as doing a ROLLBACK TRANSACTION; if any command goes wrong.\r\n\r\n## Query callbacks\r\nA callback can be a simple function, in which case it should be of the form:\r\n\r\n\tfunction finalCallback(err,rows1,result1,rows2,result2,...,rowsn,resultn) {\r\n\t\t/*\r\n\t\t\trows1 are the rows from the first query, rows2 from the second\r\n\t\t\tEach row is either an object, or an array (in case of all numeric or unnamed columns)\r\n\t\t\tresult1 will be something like \"SELECT\" for select queries, or \"UPDATE n\" for update queries.\r\n\t\t\t(see CommandComplete in http://developer.postgresql.org/pgdocs/postgres/protocol-message-formats.html)\r\n\t\t*/\r\n\t}\r\n\r\nWhile noting that only simpleQuery supports multiple queries, and as such any callback from extendedQuery will always be of the form:\r\n\r\n\tfunction finalCallback(err,rows,result) {\r\n\t\t//...\r\n\t}\r\n\r\nIn case you need more control over the callbacks, it can be an object of the following form:\r\n\r\n\t{\r\n\t\trowDescription: function(descr) {\r\n\t\t\t/*\r\n\t\t\tdescr is an array of columns, where each column has the following form:\r\n\t\t\t{\r\n\t\t\t\tfieldName: String,\r\n\t\t\t\ttableOID: Integer,\r\n\t\t\t\tcolumnAttribute: Integer,\r\n\t\t\t\tdatatypeOID: Integer,\r\n\t\t\t\tdatatypesize: Integer,\r\n\t\t\t\ttypemodifier: Integer,\r\n\t\t\t\tformatcode: Integer\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSee RowDescription command for more info\r\n\t\t\t*/ \r\n\t\t},\r\n\t\tdataRow: function(row) {\r\n\t\t\t/*\r\n\t\t\tSignals a new data row\r\n\t\t\trow is now an object or an array\r\n\t\t\tNote that fields with a name of '?column?' will be set by their index, instead of their name.\r\n\t\t\tSee DataRow command for more info\r\n\t\t\t*/ \r\n\t\t},\r\n\t\tcopyOut: function(format,columns) {\r\n\t\t\t/*\r\n\t\t\tSignals the beginning of a COPY ... TO STDOUT command.\r\n\t\t\tSee CopyOutResponse for more info\r\n\t\t\t*/\r\n\t\t},\r\n\t\tcopyData: function(buffer) {\r\n\t\t\t/*\r\n\t\t\tSignals data from a COPY ... TO STDOUT command.\r\n\t\t\tNote that PostgreSQL promises that the backend will send each row in a seperate CopyData\r\n\t\t\tAs such, there is no need to buffer and split on newlines,\r\n\t\t\tinstead just ignore the final newline, and treat each CopyData as a seperate row.\r\n\t\t\tSee CopyOutData for more info\r\n\t\t\t*/\r\n\t\t},\r\n\t\tcopyDone: function() {\r\n\t\t\t/*\r\n\t\t\tSignals the end of a COPY ... TO STDOUT command.\r\n\t\t\tSee CopyOutResponse for more info\r\n\t\t\t*/\r\n\t\t},\r\n\t\tcopyIn: function(str) {\r\n\t\t\t/*\r\n\t\t\tSignals a CopyIn operation.\r\n\t\t\tstr is similar to a WritableStream\r\n\t\t\tstr.write(buffer) to send CopyData,\r\n\t\t\tstr.end(buffer) to send CopyDone,\r\n\t\t\tstr.destroy() to send a generic CopyFail,\r\n\t\t\tor str.fail(message) to send a CopyFail with a message.\r\n\t\t\tSee CopyInResponse for more info.\r\n\t\t\t*/\r\n\t\t},\r\n\t\tcommandComplete: function(rows,result) {\r\n\t\t\t/*\r\n\t\t\tSignals the end of a query.\r\n\t\t\tNote that rows will be empty if a dataRow function exists.\r\n\t\t\tSee CommandComplete for more info.\r\n\t\t\t*/\r\n\t\t},\r\n\t\tcomplete: function(err,rows,result,rows1,result1,...) {\r\n\t\t\t/*\r\n\t\t\tSignals the end of all queries contained in the request.\r\n\t\t\tNote that rows and result will not be passed if a commandComplete function exists.\r\n\t\t\t*/\r\n\t\t}\r\n\t}\r\n\r\nPlease note that the \"complete\" function, with or without an error, will signal the end of the query, and no other methods of your callback object will be called after this.\r\n## Protocol overview\r\nA list of protocol commands and their explanation can be found [here](http://www.postgresql.org/docs/8.2/static/protocol.html).",
  "readmeFilename": "README.md",
  "_id": "PostgresClient@0.0.2",
  "_from": "PostgresClient@"
}
